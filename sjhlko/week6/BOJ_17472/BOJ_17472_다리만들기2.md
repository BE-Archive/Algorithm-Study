# ë‹¤ë¦¬ ë§Œë“¤ê¸°2

ì£¼ì°¨: 2ì›” 5ì£¼ì°¨
ë‚œì´ë„: ê³¨ë“œ1
ë§í¬: https://www.acmicpc.net/problem/17472
ì†Œìš” ì‹œê°„: 2ì‹œê°„
ì•Œê³ ë¦¬ì¦˜: union-find, êµ¬í˜„

# ë¬¸ì œ â“
![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/8d52df19-8e3f-4981-8aa7-0d7dd0beadb3)

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/5f14531a-3989-4898-83df-74bb63856dde)

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/69becd7a-d270-443c-9325-fe8fcbe8fdb6)
# ì…ì¶œë ¥ âŒ¨ï¸

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/391424c4-4f20-4900-9ade-12c438d13f0b)

# í’€ì´ ğŸ“š

## ì‚¬ê³  ê³¼ì • ğŸ¤”

ì²˜ìŒì—ëŠ” ì–´ë µê²Œ ìƒê°í–ˆë‹¤. ë‹¤ë¦¬ë¥¼ ì‡ëŠ”ë‹¤ëŠ”ê²ƒì´ ë‹¿ê¸°ë§Œ í•˜ë©´ ë˜ëŠ” ê²ƒì´ì•„ë‹ˆë¼, **íŠ¹ì • ë°©í–¥ìœ¼ë¡œ ì§ì§„í–ˆì„ë•Œ í•´ë‹¹ ì§ì§„ ë°©í–¥í•˜ê³  ë‹¿ì•„ì•¼ ë˜ëŠ” ë¡œì§**ì´ì—ˆê¸° ë•Œë¬¸ì´ë‹¤.

ì‚¬ì‹¤ ì´ ë¶€ë¶„ì€ ì˜¤íˆë ¤ ìœ ì €ë¥¼ ë°°ë ¤í•œ ë¬¸ì œ ì œí•œì´ë¼ê³  ë³¼ ìˆ˜ ìˆë‹¤. ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ì–´ë–¤ ë‹¨ê³„ê°€ í•„ìš”í• ê¹Œ?

### 1ï¸âƒ£ ì„¬ì„ ì •ì˜í•œë‹¤.

---

ì„¬ì— ì²˜ìŒë¶€í„° ìˆ«ìê°€ ë¶™ì–´ì„œ ë‚˜ì˜¨ë‹¤ë©´ ì¢‹ê² ì§€ë§Œ, **ë•…ì¸ ë¶€ë¶„ì€ 1ë¡œë§Œ í‘œì‹œ**ê°€ ë˜ì–´ìˆê¸° ë•Œë¬¸ì— **ì–´ë””ì„œë¶€í„° ì–´ë””ê¹Œì§€ê°€ í•œ ë­‰í……ì´ì¸ì§€ ì‚¬ì „ì— ë¼ë²¨ë§**ì„ í•´ì£¼ì–´ì•¼í•œë‹¤.

ìš°ì„  ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§€ëŠ” ìˆ«ì ì¤‘ 1ì€ ë•…ì„ ì˜ë¯¸í•˜ê³ , 0 ì€ ë°”ë‹¤ë¥¼ ì˜ë¯¸í•˜ê¸° ë•Œë¬¸ì—

**0ê³¼ 1 ì„ ì œì™¸í•œ ìˆ«ìë¡œ ì„¬ë“¤ì„ ë¼ë²¨ë§**í•´ì•¼í•œë‹¤.

ë‚˜ì˜ ê²½ìš° **2ë¶€í„° Nê¹Œì§€ì˜ ìˆ«ìë¡œ ì„¬ì„ í‘œì‹œ**í•˜ì˜€ë‹¤. ì„¬ì˜ ê°œìˆ˜ê°€ ìµœëŒ€ 6ê°œë°–ì— ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë¬¸ì œê°€ ì—†ë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ë¡œì§ì„ í†µí•´ ë¼ë²¨ë§ì„ í•  ìˆ˜ ìˆê² ë‹¤.

1. ì²˜ìŒì— ë§¤ê¸¸ **ì„¬ì˜ ì¸ë±ìŠ¤ë¥¼ 2ë¡œ ì´ˆê¸°í™”** í•˜ê³  ë‹¤ìŒì„ ë°˜ë³µí•œë‹¤.
2. mapì„ ì „ì²´ ìˆœíšŒí•˜ë©´ì„œ **1ì¸ ë¶€ë¶„ì„ ì°¾ëŠ”ë‹¤**.
    1. ì°¾ì•˜ë‹¤ë©´ **ë”ì´ìƒ ì¸ì ‘í•œ 1ì´ ì—†ì„ë•Œê¹Œì§€ ë‹¤ìŒì„ ë°˜ë³µ**í•œë‹¤.
        1. ì‚¬ë°©ì„ íƒìƒ‰í•˜ë©´ì„œ ì¸ì ‘í•œ **1ì¸ ë¶€ë¶„ì„ ëª¨ë‘ ì°¾ëŠ”ë‹¤**.
        2. 1ì´ì—ˆë˜ ë¶€ë¶„ì˜ **ê°’ì„ ì„¬ì˜ ì¸ë±ìŠ¤ë¡œ ë°”ê¾¸ì–´ì¤€ë‹¤.**
    2. ë°˜ë³µì´ ì¢…ë£Œëë‹¤ë©´ **ì¸ë±ìŠ¤ë¥¼ + 1í•´ì£¼ê³ ** ë¡œì§ì„ ë°˜ë³µí•œë‹¤. 

ë‹¨ìˆœí•œ **BFS**ë¥¼ í†µí•´ ì„¬ì˜ ë¼ë²¨ë§ì„ ëëƒˆë‹¤. ëŒ€ëµ **100log(100 + 400) ì •ë„ì˜ ê°„ë‹¨í•œ ì‹œê°„ì— í•´ê²°**í•  ìˆ˜ ìˆë‹¤.

### 2ï¸âƒ£ ì´ì„ ìˆ˜ ìˆëŠ” ë‹¤ë¦¬ë“¤ì„ ì°¾ëŠ”ë‹¤

---

ë‹¤ë¦¬ê°€ **ì‚¬ë°©ìœ¼ë¡œ ì§ì„  ë°©í–¥ë§Œìœ¼ë¡œ ê°€ëŠ¥**í•˜ê¸° ë•Œë¬¸ì— ì˜¤íˆë ¤ ë” ì‰½ë‹¤. ì„¬ì„ ë‚˜ëˆ„ì—ˆë‹¤ë©´ **ì„¬ì˜ íŠ¹ì • ì§€ì ì—ì„œ ì‚¬ë°©ìœ¼ë¡œ ì§ì§„í•˜ì—¬ ë»—ì–´ë‚˜ê°€ë©°** ë‹¤ë¥¸ ì„¬ìœ¼ë¡œ ë‹¤ë¦¬ë¥¼ ì„¸ìš¸ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ë©´ ë˜ê¸° ë•Œë¬¸ì´ë‹¤. ë‹¤ë¦¬ë¥¼ ì°¾ì•„ í•´ë‹¹ ë‹¤ë¦¬ë“¤ì„ ì €ì¥í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— ë”°ë¡œ class ë¥¼ ì •ì˜í•˜ë©´ ë˜ê² ë‹¤. ë‹¤ìŒì˜ ë¡œì§ì„ í†µí•´ ìœ íš¨í•œ ë‹¤ë¦¬ë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤.

1. **mapì„ ì „ì²´ ìˆœíšŒ**í•˜ë©° **ìˆ«ìê°€ 2 ì´ìƒì¸ ì§€ì **ì— ëŒ€í•´ ë‹¤ìŒì„ ë°˜ë³µí•œë‹¤.
    1. í•´ë‹¹ ì§€ì ìœ¼ë¡œë¶€í„° **4ë°©í–¥ì— ëŒ€í•´ ë‹¤ìŒì„ ë°˜ë³µ**í•œë‹¤.
        1. í•´ë‹¹ ì§€ì ìœ¼ë¡œë¶€í„° **í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ í•œì¹¸ ë” ë©€ì–´ì§„ ë¶€ë¶„**ì— ëŒ€í•´ì„œ
            1. **ìˆ«ìê°€ ë‚˜ì™”**ë‹¤ë©´
                1. **í•´ë‹¹ ìˆ«ìê°€ ìê¸° ìì‹ **ì´ë¼ë©´ ë‹¤ë¥¸ ì„¬ìœ¼ë¡œ **ë‹¤ë¦¬ë¥¼ ë†“ì„ ìˆ˜ ì—†ëŠ” ë°©í–¥ì´ë¯€ë¡œ iì˜ ë°˜ë³µì„ ì¢…ë£Œ**í•œë‹¤.
                2. í•´ë‹¹ ìˆ«ìê°€ **ë‹¤ë¥¸ ì„¬**ì´ë¼ë©´
                    1. ì´ì œê» ì™”ë˜ **ë‹¤ë¦¬ì˜ í¬ê¸°ë¥¼ í™•ì¸í•´ 1ì´ë¼ë©´** ìœ íš¨í•œ ë‹¤ë¦¬ê°€ ì•„ë‹ˆë¯€ë¡œ **iì˜ ë°˜ë³µì„ ì¢…ë£Œ**í•œë‹¤.
                    2. ë‹¤ë¦¬ì˜ **í¬ê¸°ê°€ 2ì´ìƒì´ë¼ë©´ ë‹¤ë¦¬ë¥¼ ë†“ì„ ìˆ˜ ìˆëŠ” ê²ƒ**ì´ë¯€ë¡œ **í•´ë‹¹ ë‹¤ë¦¬ë¥¼ ì €ì¥**í•˜ê³  **iì˜ ë°˜ë³µì„ ì¢…ë£Œ**í•œë‹¤.
            2. **0ì´ ë‚˜ì™”ë‹¤ë©´** ì´ì œê» ë†“ì•„ì•¼ ë˜ëŠ” **ë‹¤ë¦¬ì˜ í¬ê¸°ë¥¼ +1 í•˜ê³  ië¡œì§ì„ ë°˜ë³µ**í•œë‹¤.

ì„¬ì˜ ëª¨ë“  ì¹¸ì— ëŒ€í•´ì„œ ëª¨ë“  ë°©í–¥ìœ¼ë¡œ ì§ì§„í•  ìˆ˜ ìˆëŠ” ë§Œí¼ ì§ì§„í•˜ì—¬ í™•ì¸ì„ í•´ì•¼ í•˜ë¯€ë¡œ **O(100) * O(10) * O(4) ì •ë„ì˜ ê°„ë‹¨í•œ ì‹œê°„ë³µì¡ë„**ë¡œ ê°€ëŠ¥í•˜ë‹¤.

### 3ï¸âƒ£ êµ¬í•œ ë‹¤ë¦¬ë“¤ ì¤‘ì—ì„œ ìµœëŒ€í•œ ë‹¤ë¦¬ì˜ ì´ ê¸¸ì´ í•©ì´ ì§§ê²Œ ëª¨ë“  ì„¬ì„ ì´ì„ ìˆ˜ ìˆëŠ” ë‹¤ë¦¬ë“¤ì„ ì°¾ëŠ”ë‹¤

---

ì‚¬ì‹¤ ì´ë ‡ê²Œ ë¬¸ì œë¥¼ ì •ì˜í•´ë†“ê³  ë³´ë‹ˆ ë°”ë¡œ ë¬´ìŠ¨ ì•Œê³ ë¦¬ì¦˜ì„ ì¨ì•¼í• ì§€ ëˆˆì— ë“¤ì–´ì˜¤ì§€ ì•ŠëŠ”ê°€? **ë°”ë¡œ í¬ë£¨ìŠ¤ì¹¼/í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•´ MSTë¥¼ ì°¾ìœ¼ë©´ ë˜ëŠ”ê²ƒ**ì´ë‹¤.

ì‹¬ì§€ì–´ ì¹œì ˆí•˜ê²Œ ë‹¤ë¦¬ë¥¼ ì¤‘ë³µìœ¼ë¡œ ë†“ì•„ë„ ì¤‘ë³µìœ¼ë¡œ ë†“ì€ë§Œí¼ ê°œìˆ˜ë¥¼ ë” ì„¸ì£¼ì–´ì•¼í•œë‹¤. (ë‹¤ë¦¬ì˜ zì¶•ì´ ë‹¤ë¥¸ê°€..?)

ìœ„ì—ì„œ ì •ì˜í•´ë†“ì•˜ë˜ ë‹¤ë¦¬ë“¤ì„ í¬ê¸°ìˆœìœ¼ë¡œ ì •ë ¬í•œë’¤, ë‹¤ë¦¬ê°€ ì§§ì€ê²ƒë¶€í„° ì„¬ì„ ì´ì–´ì£¼ê³  í•´ë‹¹ ì„¬ì´ ì´ë¯¸ unionì´ ë˜ì—ˆë‹¤ë©´ ë„˜ì–´ê°€ê³  ì•„ë‹ˆë¼ë©´ unioní•´ì¤€ë’¤ ì´ì€ ê°„ì„  ê°œìˆ˜ë¥¼ ëŠ˜ë ¤ì¤€ë‹¤. ì´ì€ ê°„ì„ ê°œìˆ˜ê°€ ì„¬ê°œìˆ˜ - 1 ì´ë¼ë©´ íŠ¸ë¦¬ê°€ ë§Œë“¤ì–´ì§„ ê²ƒì´ë¯€ë¡œ ì¢…ë£Œí•˜ë©´ ëœë‹¤.

## í’€ì´ ìš”ì•½ ğŸ‘

## êµ¬í˜„ âœï¸

```java
static PriorityQueue<Edge> edges = new PriorityQueue<>();
static class Edge implements Comparable<Edge> {
        int start;
        int end;
        int cost;

        public Edge(int start, int end, int cost) {
            this.start = start;
            this.end = end;
            this.cost = cost;
        }

        @Override
        public int compareTo(Edge o) {
            return cost - o.cost;
        }
    }
```

ê°„ì„  ì •ë³´ë¥¼ ì €ì¥í•  í´ë˜ìŠ¤, ê°„ì„ ì˜ ê¸¸ì´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ê²Œë” Comparableì¸í„°í˜ì´ìŠ¤ë¥¼ implementí•œë‹¤.

```java
 static void bfs(int i, int j, int index) {
        boolean[][] visited = new boolean[N][M];
        Queue<int[]> queue = new ArrayDeque<>();
        visited[i][j] = true;
        queue.offer(new int[] { i, j });
        while (!queue.isEmpty()) {
            int[] now = queue.poll();
            map[now[0]][now[1]] = index;
            for (int k = 0; k < 4; k++) {
                int nextI = now[0] + dx[k];
                int nextJ = now[1] + dy[k];
                if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= M)
                    continue;
                if (visited[nextI][nextJ])
                    continue;
                if (map[nextI][nextJ] != 1)
                    continue;
                visited[nextI][nextJ] = true;
                queue.offer(new int[] { nextI, nextJ });
            }
        }
    }
```

ì„¬ì„ ì¸ë±ì‹± í•˜ê¸° ìœ„í•´ bfsë¥¼ ìˆ˜í–‰í•´ì•¼í•œë‹¤.

```java
static void indexingIslands() {
    int index = 2;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (map[i][j] != 1)
                continue;
            bfs(i, j, index++);
        }
    }
    iCount = index;
}
```

ì„¬ì„ ì¸ë±ì‹±í•´ì¤€ë‹¤. **iCountì— ì„¬ì˜ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤ ë²ˆí˜¸ + 1 ì„ ì €ì¥**í•˜ì—¬ ì„¬ì˜ ë²ˆí˜¸ë¥¼ ì¡°ê±´ìœ¼ë¡œ í•˜ì—¬ ë°˜ë³µë¬¸ì„ ìˆ˜í–‰í• ë•Œì˜ ì¡°ê±´ìœ¼ë¡œ í™œìš©í•  ìˆ˜ ìˆë‹¤.

```java
static int find(int x) {
    if (parent[x] < 0)
        return x;
    return parent[x] = find(parent[x]);
}

static boolean union(int x, int y) {
    int px = find(x);
    int py = find(y);
    if (px == py)
        return false;
    if (height[py] > height[px]) {
        int tmp = px;
        px = py;
        py = tmp;
    }
    if (height[px] == height[py])
        height[px]++;
    parent[px] += parent[py];
    parent[py] = px;
    return true;
}
```

ê°„ë‹¨í•œ union- find ë¡œì§ì´ë‹¤. parentì—ëŠ” í•´ë‹¹ íŠ¸ë¦¬ì˜ ë…¸ë“œì˜ ê°œìˆ˜ë¥¼ ìŒìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥í•˜ë„ë¡ í–ˆë‹¤. ë˜í•œ ì´ë¯¸ ê°™ì€ ê·¸ë£¹ì— ì†í•œê²½ìš° false, ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš° trueë¥¼ ë¦¬í„´í•˜ê²Œ í•œë‹¤.

```java
static void makeEdge(int index) {
    int[] visited = new int[iCount];
    Arrays.fill(visited, Integer.MAX_VALUE);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (map[i][j] != index)
                continue;
            for (int k = 0; k < 4; k++) {
                int count = 0;
                int nextI = i;
                int nextJ = j;
                while (true) {
                    nextI += dx[k];
                    nextJ += dy[k];
                    if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= M)
                        break;
                    if (map[nextI][nextJ] == index)
                        break;
                    if (map[nextI][nextJ] != 0) {
                        if (count == 1)
                            break;
                        if (visited[map[nextI][nextJ]] <= count)
                            break;
                        visited[map[nextI][nextJ]] = count;
                        edges.add(new Edge(map[i][j], map[nextI][nextJ], count));
                        break;
                    }
                    count++;
                }
            }
        }
    }
}

```

ì„¬ì—ì„œ ì„¬ìœ¼ë¡œ ì´ì„ ìˆ˜ ìˆëŠ” ë‹¤ë¦¬ë¥¼ êµ¬í•˜ëŠ” ë©”ì†Œë“œì´ë‹¤. ì •í•´ì§„ ë°©í–¥ìœ¼ë¡œ í•œì¹¸í•œì¹¸ ë‚˜ì•„ê°€ë©° ì°¾ê³ , ê¸¸ì´ê°€ 2 ì´ìƒì¸ ë‹¤ë¦¬ë§Œ ì €ì¥í•´ì¤€ë‹¤.

```java
static int connect() {
    for (int i = 2; i < iCount; i++) {
        makeEdge(i);
    }
    parent = new int[iCount];
    height = new int[iCount];
    Arrays.fill(parent, -1);
    int ans = 0;
    int count = 0;
    while (!edges.isEmpty()) {
        if (count == iCount - 3)
            return ans;
        Edge e = edges.poll();
        if (union(e.start, e.end)) {
            ans += e.cost;
            count++;
        }
    }
    return count == iCount - 3 ? ans : -1;
}
```

ì§§ì€ ê°„ì„ ë¶€í„° ë½‘ì•„ ì´ì–´ì¤€ë‹¤ (union) ì´ë•Œ unionì˜ ë¦¬í„´ê°’ì„ booleanìœ¼ë¡œ í–ˆê¸° ë•Œë¬¸ì— ì´ì–´ì§€ì§€ ì•Šì•˜ëŠ”ì§€ì— ëŒ€í•œ íŒë‹¨ì„ ê°„ë‹¨íˆ í•  ìˆ˜ ìˆë‹¤. ê°„ì„ ì„ ì„¬ ê°œìˆ˜ -1 (iCount-1) ë§Œí¼ í•˜ì˜€ë‹¤ë©´ ì„±ê³µ, ì•„ë‹ˆë©´ ì‹¤íŒ¨ì´ë‹¤.

# ì „ì²´ ì½”ë“œ ğŸ–¥ï¸

## ë‚´ ì½”ë“œ ğŸ˜

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;
public class MakingBridge {
    // https://www.acmicpc.net/problem/17472
    // ë‹¤ë¦¬ ë§Œë“¤ê¸° 2

    static int N, M, iCount;
    static int[][] map;
    static int[] parent, height;
    static int[] dx = { -1, 1, 0, 0 }, dy = { 0, 0, -1, 1 };
    static PriorityQueue<Edge> edges = new PriorityQueue<>();

    static class Edge implements Comparable<Edge> {
        int start;
        int end;
        int cost;

        public Edge(int start, int end, int cost) {
            this.start = start;
            this.end = end;
            this.cost = cost;
        }

        @Override
        public int compareTo(Edge o) {
            return cost - o.cost;
        }
    }

    static void bfs(int i, int j, int index) {
        boolean[][] visited = new boolean[N][M];
        Queue<int[]> queue = new ArrayDeque<>();
        visited[i][j] = true;
        queue.offer(new int[] { i, j });
        while (!queue.isEmpty()) {
            int[] now = queue.poll();
            map[now[0]][now[1]] = index;
            for (int k = 0; k < 4; k++) {
                int nextI = now[0] + dx[k];
                int nextJ = now[1] + dy[k];
                if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= M)
                    continue;
                if (visited[nextI][nextJ])
                    continue;
                if (map[nextI][nextJ] != 1)
                    continue;
                visited[nextI][nextJ] = true;
                queue.offer(new int[] { nextI, nextJ });
            }
        }
    }

    static void indexingIslands() {
        int index = 2;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (map[i][j] != 1)
                    continue;
                bfs(i, j, index++);
            }
        }
        iCount = index;
    }

    static int find(int x) {
        if (parent[x] < 0)
            return x;
        return parent[x] = find(parent[x]);
    }

    static boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py)
            return false;
        if (height[py] > height[px]) {
            int tmp = px;
            px = py;
            py = tmp;
        }
        if (height[px] == height[py])
            height[px]++;
        parent[px] += parent[py];
        parent[py] = px;
        return true;
    }

    static void makeEdge(int index) {
        int[] visited = new int[iCount];
        Arrays.fill(visited, Integer.MAX_VALUE);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (map[i][j] != index)
                    continue;
                for (int k = 0; k < 4; k++) {
                    int count = 0;
                    int nextI = i;
                    int nextJ = j;
                    while (true) {
                        nextI += dx[k];
                        nextJ += dy[k];
                        if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= M)
                            break;
                        if (map[nextI][nextJ] == index)
                            break;
                        if (map[nextI][nextJ] != 0) {
                            if (count == 1)
                                break;
                            if (visited[map[nextI][nextJ]] <= count)
                                break;
                            visited[map[nextI][nextJ]] = count;
                            edges.add(new Edge(map[i][j], map[nextI][nextJ], count));
                            break;
                        }
                        count++;
                    }
                }
            }
        }
    }

    static int connect() {
        for (int i = 2; i < iCount; i++) {
            makeEdge(i);
        }
        parent = new int[iCount];
        height = new int[iCount];
        Arrays.fill(parent, -1);
        int ans = 0;
        int count = 0;
        while (!edges.isEmpty()) {
            if (count == iCount - 3)
                return ans;
            Edge e = edges.poll();
            if (union(e.start, e.end)) {
                ans += e.cost;
                count++;
            }
        }
        return count == iCount - 3 ? ans : -1;
    }

    static int solution() {
        indexingIslands();
        return connect();

    }

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(bf.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        map = new int[N][M];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(bf.readLine());
            for (int j = 0; j < M; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        System.out.println(solution());
    }
}

```