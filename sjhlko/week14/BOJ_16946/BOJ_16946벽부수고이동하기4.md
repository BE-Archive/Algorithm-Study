# ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸° 4

ì£¼ì°¨: 4ì›” 4ì£¼ì°¨
ë‚œì´ë„: ê³¨ë“œ2
ë§í¬: https://www.acmicpc.net/problem/16946
ì†Œìš”ì‹œê°„: 1ì‹œê°„
ì•Œê³ ë¦¬ì¦˜: BFS, union-find

# ë¬¸ì œ â“

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/fa54d28a-3a85-4501-b3e6-8fb2f332eae1)
# ì…ì¶œë ¥ âŒ¨ï¸

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/b779a82b-8125-40ec-b52f-c6f9b9ded033)

# í’€ì´ ğŸ“š

## ì‚¬ê³  ê³¼ì • ğŸ¤”

1. íŠ¹ì • ë²½ì—ì„œ ì‹œì‘í•´ì„œ bfsë¥¼ ëŒë ¤ì„œ 0ì¸ ì¹¸ì¼ë•Œë§Œ ë»—ì–´ë‚˜ê°€ê²Œ í•œë‹¤ â†’ ëŒ€ëµì ìœ¼ë¡œ **(N*M)^2** ì •ë„ì˜ ì‹œê°„ë³µì¡ë„ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤.
2. ë²½ì´ ì•„ë‹Œ ê³µê°„ë“¤ì— ëŒ€í•´ì„œ union - find ë¥¼ ì´ìš©í•´ì„œ ì¸ì ‘í•œ ê³³ ë“¤ ë¼ë¦¬ í•©ì³ì¤€ë‹¤.
    
    â†’ ê° ìœ„ì¹˜ì— ëŒ€í•´ í•œë²ˆì”©ë§Œ íƒìƒ‰í•˜ê²Œ ë˜ê¸° ë•Œë¬¸ì— **(N*M)**ì— ê°€ê¹ê²Œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.
    

## í’€ì´ ìš”ì•½ ğŸ‘

1. ë²½ì´ ì•„ë‹Œ ê³µê°„ë“¤ì„ ëŒ€ìƒìœ¼ë¡œ ì¸ì ‘í•œ ê³³ë“¤ë¼ë¦¬ í•©ì³ì¤€ë‹¤. 
2. ë²½ì¸ ê³µê°„ë“¤ì„ ëŒ€ìƒìœ¼ë¡œ ìƒ, í•˜, ì¢Œ, ìš° ì— ìœ„ì¹˜í•œ ë²½ì´ ì•„ë‹Œ ê³³ë“¤ì˜ ë£¨íŠ¸ë…¸ë“œë¥¼ ê°ê° ì°¾ì€ ë’¤, í•´ë‹¹ ë£¨íŠ¸ ë…¸ë“œë“¤ì— ì—®ì¸ ê·¸ë£¹ì›ì˜ ìˆ˜ë¥¼ ê³„ì‚°í•´ì¤€ë‹¤.

## êµ¬í˜„ âœï¸

```jsx
static void init() {
    parent = new int[N * M];
    height = new int[N * M];
    Arrays.fill(parent, -1);
    boolean[][] visited = new boolean[N][M];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (visited[i][j]) continue;
            if (map[i][j] == '1') continue;
            visited[i][j] = true;
            Queue<int[]> queue = new ArrayDeque<>();
            queue.add(new int[]{i, j});
            while (!queue.isEmpty()) {
                int[] now = queue.poll();
                for (int k = 0; k < 4; k++) {
                    int nextI = now[0] + dx[k];
                    int nextJ = now[1] + dy[k];
                    if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= M) continue;
                    if (map[nextI][nextJ] == '1') continue;
                    if (visited[nextI][nextJ]) continue;
                    visited[nextI][nextJ] = true;
                    union(i * M + j, nextI * M + nextJ);
                    queue.add(new int[]{nextI, nextJ});
                }
            }
        }
    }
}
```

ê° ì¢Œí‘œì— ëŒ€í•´ì„œ ì™¼ìª½ ìœ„ë¶€í„° ì˜¤ë¥¸ìª½ ì•„ë˜ê¹Œì§€ **`0~N*M-1`**ê¹Œì§€ ìˆœì„œëŒ€ë¡œ ë²ˆí˜¸ë¥¼ ë§¤ê¸´ë‹¤. ë¶€ëª¨ ë…¸ë“œì˜ ì¸ë±ìŠ¤ë¥¼ ì €ì¥í•  ë•Œë„ í•´ë‹¹ ë²ˆí˜¸ë¥¼ ì´ìš©í•œë‹¤.

ë”°ë¼ì„œ i,j ì˜ ë²ˆí˜¸ëŠ” **`i * M + j, nextI * M + nextJ`** ê°€ ëœë‹¤.

```jsx
static void solution() {
    init();
    int[][] ans = new int[N][M];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (map[i][j] == '0') continue;
            ans[i][j] = 1;
            HashSet<Integer> keys = new HashSet<>();
            for (int k = 0; k < 4; k++) {
                int nextI = i + dx[k];
                int nextJ = j + dy[k];
                if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= M) continue;
                if (map[nextI][nextJ] == '1') continue;
                int pNext = find(nextI * M + nextJ);
                if (keys.contains(pNext)) continue;
                keys.add(pNext);
                ans[i][j] -= parent[pNext];
                ans[i][j] %= 10;
            }
        }
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            sb.append(ans[i][j] %10);
        }
        sb.append("\n");
    }
    System.out.println(sb);
}
```

ì‚¬ë°©ì˜ ë²½ì´ ì•„ë‹Œ ê³³ë“¤ì˜ ë£¨íŠ¸ë…¸ë“œë¥¼ ì°¾ê³ , ì¤‘ë³µê³„ì‚°ì„ ë§‰ê¸° ìœ„í•´ set ì„ ì´ìš©í•´ì„œ ì²˜ë¦¬í•œë‹¤. ì´ë•Œ parent[ë£¨íŠ¸ë…¸ë“œ] ì—ëŠ” í•´ë‹¹ ê·¸ë£¹ì˜ ê·¸ë£¹ì› ìˆ˜ê°€ ìŒìˆ˜ë¡œ ì €ì¥ë˜ì–´ìˆê¸° ë•Œë¬¸ì— ì´ë¥¼ í™œìš©í•˜ì—¬ ê·¸ë£¹ì›ìˆ˜ë¥¼ ê³„ì‚°í•œë‹¤.

# ì „ì²´ ì½”ë“œ ğŸ–¥ï¸

```jsx
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class BreakingWall {
    //https://www.acmicpc.net/problem/16946
    //ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸° 4
    static int[] dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};
    static char[][] map;
    static int[] parent, height;
    static int N, M;

    static int find(int x) {
        if (parent[x] < 0) return x;
        return parent[x] = find(parent[x]);
    }

    static boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        if (height[px] < height[py]) {
            int tmp = px;
            px = py;
            py = tmp;
        }
        if (height[px] == height[py]) height[px]++;
        parent[px] += parent[py];
        parent[py] = px;
        height[py] = 0;
        return true;
    }

    static void init() {
        parent = new int[N * M];
        height = new int[N * M];
        Arrays.fill(parent, -1);
        boolean[][] visited = new boolean[N][M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (visited[i][j]) continue;
                if (map[i][j] == '1') continue;
                visited[i][j] = true;
                Queue<int[]> queue = new ArrayDeque<>();
                queue.add(new int[]{i, j});
                while (!queue.isEmpty()) {
                    int[] now = queue.poll();
                    for (int k = 0; k < 4; k++) {
                        int nextI = now[0] + dx[k];
                        int nextJ = now[1] + dy[k];
                        if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= M) continue;
                        if (map[nextI][nextJ] == '1') continue;
                        if (visited[nextI][nextJ]) continue;
                        visited[nextI][nextJ] = true;
                        union(i * M + j, nextI * M + nextJ);
                        queue.add(new int[]{nextI, nextJ});
                    }
                }
            }
        }
    }

    static void solution() {
        init();
        int[][] ans = new int[N][M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (map[i][j] == '0') continue;
                ans[i][j] = 1;
                HashSet<Integer> keys = new HashSet<>();
                for (int k = 0; k < 4; k++) {
                    int nextI = i + dx[k];
                    int nextJ = j + dy[k];
                    if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= M) continue;
                    if (map[nextI][nextJ] == '1') continue;
                    int pNext = find(nextI * M + nextJ);
                    if (keys.contains(pNext)) continue;
                    keys.add(pNext);
                    ans[i][j] -= parent[pNext];
                    ans[i][j] %= 10;
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                sb.append(ans[i][j] %10);
            }
            sb.append("\n");
        }
        System.out.println(sb);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(bf.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        map = new char[N][M];
        for (int i = 0; i < N; i++) {
            map[i] = bf.readLine().toCharArray();
        }
        solution();
    }
}

```

## ë³´ì™„í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤ ğŸ’¡

union find ëŒ€ì‹  ê°€ë³ê²Œ bfsë§Œìœ¼ë¡œ ë¡œì§ì„ ì²˜ë¦¬í•  ìˆ˜ ë„ ìˆë‹¤.

ì´ì–´ì ¸ìˆëŠ” ë¶€ë¶„ë“¤ì„ 0ë¶€í„° ì‹œì‘í•˜ëŠ” ì¹´ìš´íŠ¸ ë³€ìˆ˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê·¸ë£¹ ë„˜ë²„ë¥¼ ê´€ë¦¬í•  ìˆ˜ë„ ìˆê¸° ë•Œë¬¸.