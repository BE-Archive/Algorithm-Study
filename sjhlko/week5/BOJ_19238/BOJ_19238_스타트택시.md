# ìŠ¤íƒ€íŠ¸íƒì‹œ

ì£¼ì°¨: 2ì›” 4ì£¼ì°¨
ë‚œì´ë„: ê³¨ë“œ2
ë§í¬: https://www.acmicpc.net/problem/19238
ì†Œìš” ì‹œê°„: 2ì‹œê°„

# ë¬¸ì œ â“

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/ec04a4f3-ecba-4229-8b31-5bf900824098)

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/2d821c55-5976-4f56-8868-ecb0915a0c85)

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/406529d8-1734-466d-b5f4-e64e047fd9cd)

# ì…ì¶œë ¥ âŒ¨ï¸

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/f4d15ae8-af92-496f-80e9-6211f3173690)
# í’€ì´ ğŸ“š

## ì‚¬ê³  ê³¼ì • ğŸ¤”

### íŠ¹ì • ì¹¸ì—ì„œ ë‹¤ìŒìœ¼ë¡œ ì´ë™í•´ì•¼ í•  ì¹¸ìœ¼ë¡œ ìµœë‹¨ê±°ë¦¬ë¡œ ì´ë™í•˜ëŠ”ê²ƒì„ ë°˜ë³µí•˜ëŠ” ê³¼ì •ì„ ê±°ì³ì•¼ í•œë‹¤.

**Nì˜ ì œí•œì´ 20**ì´ê³ , **Mì˜ ì œí•œì€ N^2** ì´ê¸° ë•Œë¬¸ì— **2M * (ì •ì  ê°œìˆ˜ * 4(ì‚¬ë°©))**  = `2*400*400*4`  = `ì•½ 120ë§Œ`

### â†’ **BFS ë¡œ ê°€ëŠ¥í• ê²ƒì´ë‹¤.**

### íƒìƒ‰ì€ BFSë¡œ í•œë‹¤ê³  ì¹˜ê³  ê·¸ëŸ¼ ë¡œì§ì€?â€¦ ğŸ¤”

í•´ì•¼ í•˜ëŠ” **ë™ì‘**ì€ ê°„ë‹¨í•´ë³´ì¸ë‹¤.

í¬ê²Œ **ì‚¬ëŒì„ íƒœìš´ë‹¤** ì™€ **ì‚¬ëŒì„ ë„ì°©ì§€ì— ë‚´ë ¤ì¤€ë‹¤** ë¡œ ë‚˜ë‰œë‹¤.

### 1ï¸âƒ£ ì‚¬ëŒì„ íƒœìš´ë‹¤.

---

1. í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì‚¬ëŒì„ ì°¾ê¸° ìœ„í•´ **BFSë¥¼ í†µí•´ 4ë°©í–¥ì˜ ì¹¸ë“¤ì„ ì°¨ë¡€ë¡œ íƒìƒ‰**í•´ë‚˜ê°„ë‹¤.
    1. íƒìƒ‰í•´ë‚˜ê°€ë©´ì„œ **ì“´ ì—°ë£Œë¥¼ ê¸°ë¡**í•œë‹¤.
    2. **ì—°ë£Œë¥¼ ë‹¤ì¼ë‹¤ë©´** ì‚¬ëŒì„ íƒœìš¸ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ **ë¬´íš¨**í•˜ë‹¤ê³  ì²˜ë¦¬í•˜ê³  ì¢…ë£Œí•œë‹¤.
2. **ì‚¬ëŒì„ ì°¾ì•˜ë‹¤ë©´** 
    1. **ì²˜ìŒ ì°¾ì€ ê²ƒì´ë¼ë©´**
        1. **ìš°ì„ ** í˜„ì¬ ì‹œì ì— ì°¾ì€ ì‚¬ëŒì„ **íƒœìš¸ ì‚¬ëŒìœ¼ë¡œ ì§€ì •**í•œë‹¤.
    2. ì´ë¯¸ **ì„ì‹œë¡œ ì°¾ì•„ ë‘” ì‚¬ëŒì´ ìˆë‹¤ë©´**
        1. **ìƒˆë¡œ ì°¾ì€ ì‚¬ëŒì˜ ìœ„ì¹˜**ê°€ ë” ë¨¼ì € íƒœì›Œì•¼ í•˜ëŠ” ìœ„ì¹˜ì¸ì§€ (í–‰, ì—´ ë¹„êµ) **í™•ì¸**í•˜ì—¬ **ì ì ˆíˆ êµì²´**í•´ì¤€ë‹¤.
3. **ì„ì‹œë¡œ íƒœìš¸ ì‚¬ëŒì´ ì •í•´ì ¸ ìˆëŠ” ìƒí™©**ì´ë¼ë©´
    1. í˜„ì¬ ì‚¬ëŒê¹Œì§€ ì˜¤ëŠ”ë° ì“°ëŠ” ì—°ë£Œì™€, ì„ì‹œë¡œ ì°¾ì•„ë‘” ì‚¬ëŒê¹Œì§€ë„ë‹¬í–ˆì—ˆì„ ë•Œì˜ **ì—°ë£Œë¥¼ ë¹„êµ**í•œë‹¤.
        1. **ì—°ë£Œê°€ ë” ì“°ì˜€ë‹¤ë©´**, ì´ ì´í›„ì— ì°¾ëŠ” ì‚¬ëŒì€ ë¬´ì¡°ê±´ ì—°ë£Œë¥¼ ë” ì¨ì„œ ê°€ì•¼í•˜ë¯€ë¡œ **ì„ì‹œë¡œ ì €ì¥í–ˆë˜ ì‚¬ëŒì„ íƒœì›Œì•¼í•œë‹¤.**
            1. **ë‚¨ì€ ì—°ë£Œë¥¼ ê°±ì‹ **í•´ì£¼ê³ , **í˜„ì¬ ìœ„ì¹˜ë¥¼ íƒœìš¸ ì‚¬ëŒì˜ ìœ„ì¹˜ë¡œ ë°”ê¾¼ ë’¤ ì¢…ë£Œ**í•œë‹¤.
    

### 2ï¸âƒ£ ì‚¬ëŒì„ ë‚´ë ¤ì¤€ë‹¤.

---

1. ë‚´ê°€ í˜„ì¬ íƒœìš´ ì‚¬ëŒì˜ **ëª©ì ì§€ë¥¼ ìµœë‹¨ê±°ë¦¬ë¡œ ì°¾ê¸°** ìœ„í•´ **BFSë¥¼ í†µí•´ 4ë°©í–¥ì˜ ì¹¸ë“¤ì„ ì°¨ë¡€ë¡œ íƒìƒ‰**í•´ë‚˜ê°„ë‹¤.
    1. íƒìƒ‰í•´ë‚˜ê°€ë©´ì„œ **ì“´ ì—°ë£Œë¥¼ ê¸°ë¡**í•œë‹¤.
    2. **ì—°ë£Œë¥¼ ë‹¤ì¼ë‹¤ë©´** ì‚¬ëŒì„ íƒœìš¸ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ **ë¬´íš¨**í•˜ë‹¤ê³  ì²˜ë¦¬í•˜ê³  ì¢…ë£Œí•œë‹¤.
2. **ëª©ì ì§€ì— ë„ë‹¬í–ˆë‹¤ë©´ ë‚¨ì€ ì—°ë£Œë¥¼ ê°±ì‹ **í•´ì£¼ê³ , **í˜„ì¬ ìœ„ì¹˜ë¥¼ í•´ë‹¹ ìœ„ì¹˜ë¡œ ë°”ê¾¼ ë’¤ ì¢…ë£Œ**í•œë‹¤.

ë”°ë¼ì„œ ì‚¬ëŒì„ íƒœìš°ê³ , ë‚´ë ¤ì£¼ëŠ”ê²ƒì„ ë°˜ë³µí•˜ë‹¤ê°€ ì—°ë£Œê°€ ë‹¤ ë–¨ì–´ì§€ë©´ -1ì„, ì‚¬ëŒì„ ë‹¤ íƒœì›Œ ì²˜ë¦¬í–ˆë‹¤ë©´ ë‚¨ì€ ì—°ë£Œë¥¼ ì¶œë ¥í•˜ë©´ ëœë‹¤.

ë§ì€ ì‰½ë‹¤. **ìœ„ì˜ ë¡œì§ì„ ì£¼ì–´ì§„ëŒ€ë¡œ êµ¬í˜„**í•˜ë©´ ë˜ì§€ë§Œ **ì–´ë–»ê²Œ êµ¬í˜„í•´ì•¼í• ì§€ ì •í•˜ê¸° ìœ„í•´ ê³ ë ¤í•´ì•¼í•  ì£¼ì˜ì‚¬í•­**ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

### ì£¼ì˜í•´ì•¼ í•  ì â˜ ï¸

---

### 1ï¸âƒ£ ì‚¬ëŒì˜ íƒ‘ìŠ¹ ì •ë³´ë¥¼ ì €ì¥í• ë•Œ

ì²˜ìŒì—ëŠ” ê·¸ì € **ë°°ì—´ì— íƒ‘ìŠ¹ê°ë§ˆë‹¤ì˜ ì¸ë±ìŠ¤ë¥¼ ì €ì¥**í•´ì„œ ì¶œë°œì§€ë¥¼ íƒ‘ìŠ¹ê°ì˜ ì¸ë±ìŠ¤, ë„ì°©ì§€ë¥¼ íƒ‘ìŠ¹ê°ì˜ ì¸ë±ìŠ¤* -1 ë¡œ í•˜ë ¤ê³  í–ˆë‹¤.

í•˜ì§€ë§Œ ì´ ê²½ìš° ì¶œë°œì§€ëŠ” ëª¨ë‘ ë‹¤ë¥´ì§€ë§Œ **ë„ì°©ì§€ê°€ ê°™ì„ ìˆ˜ ìˆì–´ì„œ ë¶ˆê°€ëŠ¥í•˜ë‹¤.** 

ë”°ë¼ì„œ **íŠ¹ì • ì¢Œí‘œê°’ì„ í‚¤ì™€ ê°’ìœ¼ë¡œ ê°€ì§€ëŠ” í•´ì‹œ ë§µì—ë‹¤ ì €ì¥**í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í–ˆë‹¤.

### 2ï¸âƒ£ ë‹¤ìŒìœ¼ë¡œ íƒ‘ìŠ¹í•  ì‚¬ëŒì„ ê³ ë¥¼ ë•Œ

ìµœë‹¨ ì´ë™ ê±°ë¦¬ê°€ ê°™ì€ ì‚¬ëŒì— ëŒ€í•´ì„œ ì–´ë–¤ ì‚¬ëŒì„ ê³ ë¥¼ì§€ì— ëŒ€í•œ ì¡°ê±´ì„ ê³ ë ¤í•´ì•¼í•œë‹¤. í–‰ê³¼ ì—´ì´ ì‘ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„ê°€ ëœë‹¤. ê·¸ë ‡ë‹¤ê³  **ë¬´ì‘ì • ìœ„ì™€ ì™¼ìª½ì„ ë¨¼ì € íƒìƒ‰í•˜ê²Œ ë§Œë“ ë’¤ ë¨¼ì € ë‚˜ì˜¤ëŠ” ì‚¬ëŒì„ ê³¨ë¼ íƒœìš°ë©´ ì•ˆëœë‹¤.**

**ë°˜ë¡€**ëŠ” ì•„ë˜ì™€ ê°™ë‹¤. **ê¸¸ì´ ë§‰í˜€ìˆëŠ” ê²½ìš°** ê±°ë¦¬ê°€ ë˜‘ê°™ì•„ë„ íƒìƒ‰ ìˆœì„œì— ì˜í•´ **ë¶€ì ì ˆí•œ ì¢Œí‘œê°€ ë¨¼ì € íƒìƒ‰**ë˜ê²Œ ëœë‹¤.

![image](https://github.com/BE-Archive/Algorithm-Study/assets/76868151/0df9a4bb-02be-4474-b172-d4adbb3bf717)

ë”°ë¼ì„œ **ë¯¸ë¦¬ íƒœìš¸ ì‚¬ëŒì„ ì •í•´ë‘ê³ **, ê°™ì€ ì—°ë£Œë¡œ ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ì¹¸ë“¤ê¹Œì§€ëŠ” **ëª¨ë‘ íƒìƒ‰ì„ ê±°ì³ ê°€ì¥ ì ì ˆí•œ ì‚¬ëŒì„ ë½‘ì•„**ì¤˜ì•¼í•œë‹¤.

## êµ¬í˜„ âœï¸

```java
static int startI, startJ;
static int[][] map;
static boolean[][] isPassenger;
static Map<String, int[]> passengerInfo = new HashMap<>();
```

- íƒìƒ‰ì˜ ì‹œì‘ì  ì •ë³´
- ê¸°ì¡´ ë§µ ì •ë³´
- í•´ë‹¹ ì¢Œí‘œì— íƒ‘ìŠ¹ê°ì´ ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
- íƒ‘ìŠ¹ê°ì˜ ì •ë³´ë¥¼ ì €ì¥ - ì¶œë°œì§€ ì¢Œí‘œë¥¼ ë¬¸ìì—´ë¡œ ë§Œë“¤ì–´ í‚¤ë¡œ ì‚¬ìš©í•˜ê³ , ë„ì°©ì§€ ì •ë³´ë¥¼ ê°’ìœ¼ë¡œ ê°€ì§„ë‹¤.

```java
static String makeKey(int i, int j) {
    StringBuilder sb = new StringBuilder();
    sb.append(i).append(" ").append(j);
    return sb.toString();
}
```

- íŠ¹ì • ì¢Œí‘œë¥¼ í‚¤ ë¬¸ìì—´ë¡œ ë§Œë“ ë‹¤. ì´ë•Œ ê³µë°±ì„ ê¼­ ë¼ì›Œì¤˜ì•¼í•œë‹¤. ì•„ë‹ˆë©´ (1,11) ê³¼ (11,1) ê°™ì€ ê²ƒë“¤ì´ êµ¬ë¶„ì´ ì•ˆëœë‹¤.

```java
// ìœ íš¨í•˜ë©´ true, ë‹¤ìŒìœ¼ë¡œ ì´ë™í•  ìˆ˜ ì—†ëŠ” ì¡°ê±´ì´ë©´ false ë¦¬í„´
static boolean bfs(boolean hasPassenger) {
    Queue<int[]> queue = new ArrayDeque<>();
    queue.add(new int[]{startI, startJ});
    boolean[][] visited = new boolean[N][N];
    visited[startI][startJ] = true;
    int[] target = passengerInfo.get(makeKey(startI, startJ));
    int nowF = 0, targetF = Integer.MAX_VALUE;
    while (!queue.isEmpty()) {
        // í˜„ì¬ ë‹¨ê³„ê¹Œì§€ ë„ë‹¬í•˜ë©´ì„œ ì•„ë¬´ ì´ë²¤íŠ¸ë„ ë°œìƒí•˜ì§€ ì•Šì•˜ê³  ì—°ë£Œê°€ ë™ë‚¬ë‹¤ë©´ ì¢…ë£Œ
        if (nowF > F) return false;
        int size = queue.size();
        // size() ë§Œí¼ ë°˜ë³µí•¨ìœ¼ë¡œì¨ ê°™ì€ ê±°ë¦¬ì— ë–¨ì–´ì ¸ ìˆëŠ” ì¹¸ë“¤ì„ ëª¨ì•„ì„œ íƒìƒ‰í•˜ê³ , 
        // í•´ë‹¹ ë°˜ë³µì´ ëë‚˜ë©´ ì“´ ì—°ë£Œë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤.
        while (size-- > 0) {
            int[] now = queue.poll();
            // ì‚¬ëŒì´ íƒ€ìˆê³ , ëª©ì ì§€ì— ë„ë‹¬ì‹œ í•´ë‹¹ ëª©ì ì§€ë¥¼ ë‹¤ìŒ íƒìƒ‰ì‹œì‘ì§€ì ìœ¼ë¡œ ì§€ì •í›„ ì—°ë£Œë¥¼ ê¹ì•„ì¤Œ
            if (hasPassenger && target[0] == now[0] && target[1] == now[1]) {
                F += nowF;
                startI = now[0];
                startJ = now[1];
                return true;
            }
            // ì‚¬ëŒì„ ì°¾ì•„ì•¼í•˜ê³ , í˜„ì¬ ìœ„ì¹˜ì— ì‚¬ëŒì´ ìˆìœ¼ë©°, ì‚¬ëŒì„ ì²˜ìŒ íƒìƒ‰í•˜ëŠ”ê²ƒì´ê±°ë‚˜, 
					  //ì´ì „ì— íƒìƒ‰í–ˆë˜ ì‚¬ëŒë³´ë‹¤ ìœ„ ë˜ëŠ” ì™¼ìª½ì— ìˆì„ë•Œ êµí™˜
            if (!hasPassenger && isPassenger[now[0]][now[1]] &&
                    (targetF == Integer.MAX_VALUE || startI > now[0] || (startI == now[0] && startJ > now[1]))
            ) {
                targetF = nowF;
                startI = now[0];
                startJ = now[1];
            }
            for (int i = 0; i < 4; i++) {
                int nextI = now[0] + dx[i];
                int nextJ = now[1] + dy[i];
                if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= N) continue;
                if (map[nextI][nextJ] == 1) continue;
                if (visited[nextI][nextJ]) continue;
                visited[nextI][nextJ] = true;
                queue.add(new int[]{nextI, nextJ});
            }
        }
        // ì´ ì´í›„ ë°˜ë³µì€ ì—°ë£Œë¥¼ 1 ë”ì¨ì•¼ ê°ˆ ìˆ˜ ìˆëŠ” ì¹¸ë“¤ì´ë¯€ë¡œ í˜„ì‹œì ì— ì„ì‹œë¡œ íƒœìš´ ì‚¬ëŒì„ ì‹¤ì œë¡œ íƒœìš´ë‹¤.
        if (!hasPassenger && targetF != Integer.MAX_VALUE) {
            isPassenger[startI][startJ] = false;
            F -= targetF;
            return true;
        }
        nowF++;
    }
    return false;
}

```

- hasPassenger : í˜„ì¬ íƒì‹œê°€ ìŠ¹ê°ì„ íƒœì› ëŠ”ì§€
- target : í˜„ì¬ íƒì‹œì— ìŠ¹ê°ì´ íƒ€ìˆì„ë•Œ, ëª©ì ì§€ ìœ„ì¹˜
- nowF : í˜„ì¬ íƒìƒ‰ ë‹¨ê³„ê¹Œì§€ ì˜¤ëŠ”ë° ì“´ ì—°ë£Œ
- targetF : íƒœìš¸ ìŠ¹ê°ì„ ì°¾ëŠ” ìƒí™©ì¼ë•Œ í•´ë‹¹ ìŠ¹ê°ì„ ì°¾ëŠ”ë°ê¹Œì§€ ì“´ ì—°ë£Œ

```java
static void solution() {
    int count = 0;
    while (true) {
        if (count == M) {
            System.out.println(F);
            return;
        }
        if (!bfs(false) || !bfs(true)) {
            System.out.println(-1);
            return;
        }
        count++;
    }
}
```

- ë”ì´ìƒ ì‚¬ëŒì´ ì—†ìœ¼ë©´ ì—°ë£Œë¥¼ ì¶œë ¥
- ê·¸ê²ƒì´ ì•„ë‹ˆë©´ íƒœìš°ê³ , ë°ë ¤ë‹¤ì£¼ê¸°ë¥¼ ë°˜ë³µ
    - ì´ë•Œ ë¬´íš¨í•˜ë‹¤ê³  íŒë‹¨ë˜ë©´ -1 ì¶œë ¥ê³¼ ì¦‰ì‹œ ì¢…ë£Œ

# ì „ì²´ ì½”ë“œ ğŸ–¥ï¸

## ë‚´ ì½”ë“œ ğŸ˜

```java
package sjhlko.week5.BOJ_19238;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class BOJ_19238_ìŠ¤íƒ€íŠ¸íƒì‹œ {
    //https://www.acmicpc.net/problem/19238
    //ìŠ¤íƒ€íŠ¸ íƒì‹œ
    static int N, M, F;
    static int startI, startJ;
    static int[][] map;
    static boolean[][] isPassenger;
    static Map<String, int[]> passengerInfo = new HashMap<>();
    static int[] dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};

    static String makeKey(int i, int j) {
        StringBuilder sb = new StringBuilder();
        sb.append(i).append(" ").append(j);
        return sb.toString();
    }

    // ìœ íš¨í•˜ë©´ true, ë‹¤ìŒìœ¼ë¡œ ì´ë™í•  ìˆ˜ ì—†ëŠ” ì¡°ê±´ì´ë©´ false ë¦¬í„´
    static boolean bfs(boolean hasPassenger) {
        Queue<int[]> queue = new ArrayDeque<>();
        queue.add(new int[]{startI, startJ});
        boolean[][] visited = new boolean[N][N];
        visited[startI][startJ] = true;
        int[] target = passengerInfo.get(makeKey(startI, startJ));
        int nowF = 0, targetF = Integer.MAX_VALUE;
        while (!queue.isEmpty()) {
            // í˜„ì¬ ë‹¨ê³„ê¹Œì§€ ë„ë‹¬í•˜ë©´ì„œ ì•„ë¬´ ì´ë²¤íŠ¸ë„ ë°œìƒí•˜ì§€ ì•Šì•˜ê³  ì—°ë£Œê°€ ë™ë‚¬ë‹¤ë©´ ì¢…ë£Œ
            if (nowF > F) return false;
            int size = queue.size();
            // size() ë§Œí¼ ë°˜ë³µí•¨ìœ¼ë¡œì¨ ê°™ì€ ê±°ë¦¬ì— ë–¨ì–´ì ¸ ìˆëŠ” ì¹¸ë“¤ì„ ëª¨ì•„ì„œ íƒìƒ‰í•˜ê³ , í•´ë‹¹ ë°˜ë³µì´ ëë‚˜ë©´ ì“´ ì—°ë£Œë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤.
            while (size-- > 0) {
                int[] now = queue.poll();
                // ì‚¬ëŒì´ íƒ€ìˆê³ , ëª©ì ì§€ì— ë„ë‹¬ì‹œ í•´ë‹¹ ëª©ì ì§€ë¥¼ ë‹¤ìŒ íƒìƒ‰ì‹œì‘ì§€ì ìœ¼ë¡œ ì§€ì •í›„ ì—°ë£Œë¥¼ ê¹ì•„ì¤Œ
                if (hasPassenger && target[0] == now[0] && target[1] == now[1]) {
                    F += nowF;
                    startI = now[0];
                    startJ = now[1];
                    return true;
                }
                // ì‚¬ëŒì„ ì°¾ì•„ì•¼í•˜ê³ , í˜„ì¬ ìœ„ì¹˜ì— ì‚¬ëŒì´ ìˆìœ¼ë©°, ì‚¬ëŒì„ ì²˜ìŒ íƒìƒ‰í•˜ëŠ”ê²ƒì´ê±°ë‚˜, ì´ì „ì— íƒìƒ‰í–ˆë˜ ì‚¬ëŒë³´ë‹¤ ìœ„ ë˜ëŠ” ì™¼ìª½ì— ìˆì„ë•Œ êµí™˜
                if (!hasPassenger && isPassenger[now[0]][now[1]] &&
                        (targetF == Integer.MAX_VALUE || startI > now[0] || (startI == now[0] && startJ > now[1]))
                ) {
                    targetF = nowF;
                    startI = now[0];
                    startJ = now[1];
                }
                for (int i = 0; i < 4; i++) {
                    int nextI = now[0] + dx[i];
                    int nextJ = now[1] + dy[i];
                    if (nextI < 0 || nextJ < 0 || nextI >= N || nextJ >= N) continue;
                    if (map[nextI][nextJ] == 1) continue;
                    if (visited[nextI][nextJ]) continue;
                    visited[nextI][nextJ] = true;
                    queue.add(new int[]{nextI, nextJ});
                }
            }
            // ì´ ì´í›„ ë°˜ë³µì€ ì—°ë£Œë¥¼ 1 ë”ì¨ì•¼ ê°ˆ ìˆ˜ ìˆëŠ” ì¹¸ë“¤ì´ë¯€ë¡œ í˜„ì‹œì ì— ì„ì‹œë¡œ íƒœìš´ ì‚¬ëŒì„ ì‹¤ì œë¡œ íƒœìš´ë‹¤.
            if (!hasPassenger && targetF != Integer.MAX_VALUE) {
                isPassenger[startI][startJ] = false;
                F -= targetF;
                return true;
            }
            nowF++;
        }
        return false;
    }

    static void solution() {
        int count = 0;
        while (true) {
            if (count == M) {
                System.out.println(F);
                return;
            }
            if (!bfs(false) || !bfs(true)) {
                System.out.println(-1);
                return;
            }
            count++;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(bf.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        F = Integer.parseInt(st.nextToken());
        map = new int[N][N];
        isPassenger = new boolean[N][N];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(bf.readLine());
            for (int j = 0; j < N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        st = new StringTokenizer(bf.readLine());
        startI = Integer.parseInt(st.nextToken()) - 1;
        startJ = Integer.parseInt(st.nextToken()) - 1;
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(bf.readLine());
            int si = Integer.parseInt(st.nextToken()) - 1;
            int sj = Integer.parseInt(st.nextToken()) - 1;
            int ei = Integer.parseInt(st.nextToken()) - 1;
            int ej = Integer.parseInt(st.nextToken()) - 1;
            isPassenger[si][sj] = true;
            passengerInfo.put(makeKey(si, sj), new int[]{ei, ej});
        }
        solution();
    }
}

```

## ë³´ì™„í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤ ğŸ’¡

- ì¡°ê±´ì„ ì˜ ì½ì–´ì•¼ í•œë‹¤.
- ë©”ì†Œë“œë¥¼ ì¼ë‹¨ ë¨¼ì € ì„¤ê³„ë¥¼ í•˜ì (ìµœì†Œí•œ ë¦¬í„´ê°’ì´ë¼ë„)
- ì¸ë±ìŠ¤ê°€ ëª‡ë¶€í„° ì‹œì‘í•˜ëŠ”ì§€ë„ ì¤‘ìš”í•˜ë‹¤.